@inject IViewInventoriesByNameUseCase ViewInventoriesByNameUseCase

<div class="input-group">
	<input type="text" class="form-control" placeholder="Type something to search"
	@bind-value="this.searchFilter" @bind-value:event="oninput"></input>
</div>

@if(inventories is not null && inventories.Count > 0){
	<div class="search-result">
		<ul>
			@foreach (var inv in inventories){
				<li @key="inv.InventoryId" @onclick="() => {HandleSelectInventory(inv);}">
					@inv.InventoryName
				</li>
			}
		</ul>
	</div>
}
@code {
	[Parameter]
	public EventCallback<Inventory> OnInventorySelected { get; set; }

	private string _searchFilter = string.Empty;

	private string searchFilter{
		get => _searchFilter;
		set{
			_searchFilter = value;
			HandleSearch();
		}
	}
	private List<Inventory> inventories = new List<Inventory>();

	private async Task HandleSearch(){
		inventories = (await ViewInventoriesByNameUseCase.ExecuteAsync(this.searchFilter)).ToList();
		StateHasChanged(); // to inform the html that the state of the variable has changed thereby re rendering the html accoringly incase the it was originally rendered before the data was recieved from the backend
	}

	private async Task HandleSelectInventory(Inventory inventory){
		await OnInventorySelected.InvokeAsync(inventory);
		inventories.Clear();
	}
}
